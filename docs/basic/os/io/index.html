<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="I/O"><meta property="og:title" content="I/O" />
<meta property="og:description" content="I/O 基本概念 文件描述符fd 文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。
文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 UNIX、Linux 这样的操作系统。
缓存 I/O 缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
缓存 I/O 的缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。
IO模式 刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：
 等待数据准备 将数据从内核拷贝到进程中  正式因为这两个阶段，Linux系统产生了下面五种网络模式的方案。
 阻塞 I/O（blocking IO） 非阻塞 I/O（nonblocking IO） I/O 多路复用（ IO multiplexing） 信号驱动 I/O（ signal driven IO） 异步 I/O（asynchronous IO）   由于signal driven IO在实际中并不常用，所以这里只提及剩下的四种 IO Model。
 阻塞IO 在 Linux 中，默认情况下所有的 socket 都是 blocking ，一个典型的读操作流程大概是这样：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hadyang.github.io/interview/docs/basic/os/io/" />
<meta property="article:published_time" content="2019-08-21T11:00:41+08:00" />
<meta property="article:modified_time" content="2020-01-19T16:59:43+08:00" />
<title>I/O | Interview</title>
<link rel="icon" href="/interview/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/interview/book.min.68d45956421753cdf6bcfc865ede445c56afc5bcaaebfe02961f44fe77d8f45a.css" integrity="sha256-aNRZVkIXU832vPyGXt5EXFavxbyq6/4Clh9E/nfY9Fo=">


<script defer src="/interview/en.search.min.65cab4ba3e9facc6bed1810087ab9ac092c1e57b178db14c68a190592f4f9065.js" integrity="sha256-Zcq0uj6frMa&#43;0YEAh6uawJLB5XsXjbFMaKGQWS9PkGU="></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-157595781-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://hadyang.github.io/interview/"><span>Interview</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    <ul>
<li><a href="/interview/docs/basic/">计算机基础</a>
<ul>
<li><a href="/interview/docs/basic/algo/">算法</a>
<ul>
<li><a href="/interview/docs/basic/algo/tree/">树</a></li>
<li><a href="/interview/docs/basic/algo/hash/">Hash</a></li>
<li><a href="/interview/docs/basic/algo/mst/">最小生成树算法</a></li>
<li><a href="/interview/docs/basic/algo/path/">最短路径算法</a></li>
<li><a href="/interview/docs/basic/algo/kmp/">KMP算法</a></li>
<li><a href="/interview/docs/basic/algo/search/">查找算法</a></li>
<li><a href="/interview/docs/basic/algo/sort/">排序算法</a></li>
<li><a href="/interview/docs/basic/algo/skip_list/">跳跃表</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/os/">操作系统</a>
<ul>
<li><a href="/interview/docs/basic/os/arch/">计算机体系结构</a></li>
<li><a href="/interview/docs/basic/os/concurrency/">并发</a></li>
<li><a href="/interview/docs/basic/os/memory/">内存管理</a></li>
<li><a href="/interview/docs/basic/os/disk/">磁盘与文件</a></li>
<li><a href="/interview/docs/basic/os/linux/">Linux系统</a></li>
<li><a href="/interview/docs/basic/os/interrupt/">中断</a></li>
<li><a href="/interview/docs/basic/os/device/">设备管理</a></li>
<li><a href="/interview/docs/basic/os/io/"class=active>I/O</a></li>
<li><a href="/interview/docs/basic/os/questions/">面试题</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/net/">计算机网络</a>
<ul>
<li><a href="/interview/docs/basic/net/protocol/">底层网络协议</a></li>
<li><a href="/interview/docs/basic/net/tcp/">TCP</a></li>
<li><a href="/interview/docs/basic/net/ip/">IP</a></li>
<li><a href="/interview/docs/basic/net/http/">HTTP</a></li>
<li><a href="/interview/docs/basic/net/https/">HTTPS</a></li>
<li><a href="/interview/docs/basic/net/websocket/">Websocket</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/database/">数据库</a>
<ul>
<li><a href="/interview/docs/basic/database/transaction/">事务</a></li>
<li><a href="/interview/docs/basic/database/index/">索引</a></li>
<li><a href="/interview/docs/basic/database/sql/">SQL</a></li>
<li><a href="/interview/docs/basic/database/join/">连接</a></li>
<li><a href="/interview/docs/basic/database/mysql/">MySQL</a></li>
<li><a href="/interview/docs/basic/database/concurrent/">并发控制</a></li>
<li><a href="/interview/docs/basic/database/innodb/">Innodb</a></li>
<li><a href="/interview/docs/basic/database/redis/">Redis</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/cryptology/">密码学</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/">Java</a>
<ul>
<li><a href="/interview/docs/java/oop/">OOP</a></li>
<li><a href="/interview/docs/java/serilaser/">序列化</a></li>
<li><a href="/interview/docs/java/operator/">运算符</a></li>
<li><a href="/interview/docs/java/exception/">异常</a></li>
<li><a href="/interview/docs/java/generics/">泛型</a></li>
<li><a href="/interview/docs/java/object/">Object</a></li>
<li><a href="/interview/docs/java/string-builder/">StringBuilder</a></li>
<li><a href="/interview/docs/java/proxy/">代理</a></li>
<li><a href="/interview/docs/java/annotation/">注解</a></li>
<li><a href="/interview/docs/java/questions/">面试题</a></li>
<li><a href="/interview/docs/java/nio/">NIO</a></li>
<li><a href="/interview/docs/java/">集合</a>
<ul>
<li><a href="/interview/docs/java/collection/HashMap/">HashMap</a></li>
<li><a href="/interview/docs/java/collection/Concurrenthashmap/">Concurrenthashmap</a></li>
<li><a href="/interview/docs/java/collection/BlockQueue/">BlockQueue</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/concurrent/">并发</a>
<ul>
<li><a href="/interview/docs/java/concurrent/thread/">线程</a></li>
<li><a href="/interview/docs/java/concurrent/volatile/">Volatile</a></li>
<li><a href="/interview/docs/java/concurrent/atomic/">AtomicInteger</a></li>
<li><a href="/interview/docs/java/concurrent/synchronized/">Synchronized</a></li>
<li><a href="/interview/docs/java/concurrent/AQS/">AQS</a></li>
<li><a href="/interview/docs/java/concurrent/count-down-latch/">CountDownLatch</a></li>
<li><a href="/interview/docs/java/concurrent/threadlocal/">Threadlocal</a></li>
<li><a href="/interview/docs/java/concurrent/interrupt/">线程中断</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/jvm/">Java 虚拟机</a>
<ul>
<li><a href="/interview/docs/java/jvm/jvm-class-load-init/">类加载</a></li>
<li><a href="/interview/docs/java/jvm/jvm-class-loader/">类加载器</a></li>
<li><a href="/interview/docs/java/jvm/dispatcher/">Java分派机制</a></li>
<li><a href="/interview/docs/java/jvm/jvm-architecture/">虚拟机架构</a></li>
<li><a href="/interview/docs/java/jvm/memory-model/">内存模型</a></li>
<li><a href="/interview/docs/java/jvm/string-constant-pool/">String 常量池</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/gc/">GC</a>
<ul>
<li><a href="/interview/docs/java/gc/jvm-gc/">Java 虚拟机垃圾收集</a></li>
<li><a href="/interview/docs/java/gc/jvm-object-lifecycle/">Java 虚拟机对象生命周期</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/interview/docs/fromwork/">框架</a>
<ul>
<li><a href="/interview/docs/fromwork/netty/">Netty</a></li>
<li><a href="/interview/docs/fromwork/mybatis/">Mybatis</a>
<ul>
<li><a href="/interview/docs/fromwork/mybatis/question/">面试题</a></li>
<li><a href="/interview/docs/fromwork/mybatis/cache/">缓存</a></li>
<li><a href="/interview/docs/fromwork/mybatis/proxy/">代理</a></li>
</ul>
</li>
<li><a href="/interview/docs/fromwork/spring/">Spring</a>
<ul>
<li><a href="/interview/docs/fromwork/spring/ioc/">IOC</a></li>
<li><a href="/interview/docs/fromwork/spring/design-partten/">设计模式</a></li>
<li><a href="/interview/docs/fromwork/spring/aop/">AOP</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/interview/docs/architecture/">系统架构</a>
<ul>
<li><a href="/interview/docs/architecture/base/">基本概念</a></li>
<li><a href="/interview/docs/architecture/concurrent/">高并发</a>
<ul>
<li><a href="/interview/docs/architecture/concurrent/flow-control/">流量控制</a></li>
</ul>
</li>
<li><a href="/interview/docs/architecture/design/">系统设计</a>
<ul>
<li><a href="/interview/docs/architecture/design/tinyURL/">短链接系统</a></li>
</ul>
</li>
<li><a href="/interview/docs/architecture/distributed/">分布式</a>
<ul>
<li><a href="/interview/docs/architecture/distributed/consensus/">分布式一致性与共识算法</a></li>
<li><a href="/interview/docs/architecture/distributed/session/">分布式Session</a></li>
<li><a href="/interview/docs/architecture/distributed/cache/">分布式缓存</a></li>
<li><a href="/interview/docs/architecture/distributed/lock/">分布式锁</a></li>
<li><a href="/interview/docs/architecture/distributed/transaction/">分布式事务</a></li>
<li><a href="/interview/docs/architecture/distributed/mq/">消息队列</a></li>
<li><a href="/interview/docs/architecture/distributed/zk/">Zookeeper</a></li>
<li><a href="/interview/docs/architecture/distributed/kafka/">Kafka</a></li>
<li><a href="/interview/docs/architecture/distributed/rpc/">远程调用</a></li>
<li><a href="/interview/docs/architecture/distributed/dubbo/">Dubbo</a></li>
</ul>
</li>
<li><a href="/interview/docs/architecture/bigdata/">大数据</a>
<ul>
<li><a href="/interview/docs/architecture/bigdata/algo/">基础算法</a></li>
<li><a href="/interview/docs/architecture/bigdata/hdfs/">HDFS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/interview/docs/offer/">剑指offer</a>
<ul>
<li><a href="/interview/docs/offer/search-a-2d-matrix/">搜索二维矩阵</a></li>
<li><a href="/interview/docs/offer/replay-space/">替换空格</a></li>
<li><a href="/interview/docs/offer/print-link-from-tail/">从尾到头打印链表</a></li>
<li><a href="/interview/docs/offer/reConstructBinaryTree/">重建二叉树</a></li>
<li><a href="/interview/docs/offer/two-stack-fifo/">用两个栈实现一个队列</a></li>
<li><a href="/interview/docs/offer/find-minimum-in-rotated-sorted-array/">旋转数组的最小数字</a></li>
<li><a href="/interview/docs/offer/fibonacci/">斐波纳切数列</a></li>
<li><a href="/interview/docs/offer/number-of-one/">二进制中1的个数</a></li>
<li><a href="/interview/docs/offer/power/">数值的整数次方</a></li>
<li><a href="/interview/docs/offer/printn/">打印最大的 n 位数</a></li>
<li><a href="/interview/docs/offer/O1DeleteNode/">在O(1)的时间复杂度下删除节点</a></li>
<li><a href="/interview/docs/offer/reOrderArray/">调整数组顺序使奇数位于偶数前面</a></li>
<li><a href="/interview/docs/offer/FindKthToTail/">链表中倒数第k个结点</a></li>
<li><a href="/interview/docs/offer/revert-link/">反转链表</a></li>
<li><a href="/interview/docs/offer/merge-sort-link/">合并两个排序的链表</a></li>
<li><a href="/interview/docs/offer/HasSubtree/">树的子结构</a></li>
<li><a href="/interview/docs/offer/mirror-tree/">二叉树的镜像</a></li>
<li><a href="/interview/docs/offer/PrintMatrix/">顺时针打印矩阵</a></li>
<li><a href="/interview/docs/offer/MinStack/">包含min函数的栈</a></li>
<li><a href="/interview/docs/offer/IsPopOrder/">栈的压入、弹出序列</a></li>
<li><a href="/interview/docs/offer/PrintFromTopToBottom/">从上往下打印二叉树</a></li>
<li><a href="/interview/docs/offer/VerifySquenceOfBST/">二叉搜索树的后序遍历序列</a></li>
<li><a href="/interview/docs/offer/FindPath/">二叉树中和为某一值的路径</a></li>
<li><a href="/interview/docs/offer/CloneLink/">复杂链表的复制</a></li>
<li><a href="/interview/docs/offer/BST-Link-Convert/">二叉搜索树与双向链表</a></li>
<li><a href="/interview/docs/offer/Permutation/">字符串的排列</a></li>
<li><a href="/interview/docs/offer/MoreThanHalfNum/">数组中出现次数超过一半的数字</a></li>
<li><a href="/interview/docs/offer/GetLeastNumbers/">最小的K个数</a></li>
<li><a href="/interview/docs/offer/FindGreatestSumOfSubArray/">连续子数组的最大和</a></li>
<li><a href="/interview/docs/offer/NumberOfOneBetweenOneAndN/">从1到n整数中1出现的次数</a></li>
<li><a href="/interview/docs/offer/PrintMinNumber/">把数组排成最小的数</a></li>
<li><a href="/interview/docs/offer/GetUglyNumber/">丑数</a></li>
<li><a href="/interview/docs/offer/FirstNotRepeatingChar/">第一个只出现一次的字符</a></li>
<li><a href="/interview/docs/offer/InversePairs/">数组中的逆序对</a></li>
<li><a href="/interview/docs/offer/FindFirstCommonNode/">两个链表的第一个公共结点</a></li>
<li><a href="/interview/docs/offer/GetNumberOfK/">数字在排序数组中出现的次数</a></li>
<li><a href="/interview/docs/offer/TreeDepth/">二叉树的深度</a></li>
<li><a href="/interview/docs/offer/FindNumsAppearOnce/">数组中只出现一次的数字</a></li>
<li><a href="/interview/docs/offer/FindNumbersWithSum/">和为S的两个数字</a></li>
<li><a href="/interview/docs/offer/FindContinuousSequence/">和为S的连续正数序列</a></li>
<li><a href="/interview/docs/offer/ReverseSentence/">翻转单词顺序列</a></li>
<li><a href="/interview/docs/offer/LeftRotateString/">左旋转字符串</a></li>
<li><a href="/interview/docs/offer/SumOfNDice/">n个骰子的点数</a></li>
<li><a href="/interview/docs/offer/isContinuous/">扑克牌顺子</a></li>
<li><a href="/interview/docs/offer/LastRemaining/">圆圈中最后剩下的数</a></li>
<li><a href="/interview/docs/offer/sum/">求1+2+3+&hellip;+n</a></li>
<li><a href="/interview/docs/offer/Add/">不用加减乘除做加法</a></li>
<li><a href="/interview/docs/offer/Singleton/">单例</a></li>
<li><a href="/interview/docs/offer/Duplicate/">数组中重复的数字</a></li>
<li><a href="/interview/docs/offer/GetNext/">二叉树的下一个结点</a></li>
<li><a href="/interview/docs/offer/hasPath/">矩阵中的路径</a></li>
<li><a href="/interview/docs/offer/MovingCount/">机器人的运动范围</a></li>
<li><a href="/interview/docs/offer/CutRope/">剪绳子</a></li>
<li><a href="/interview/docs/offer/PatternMatch/">正则表达式匹配</a></li>
<li><a href="/interview/docs/offer/IsNumeric/">表示数值的字符串</a></li>
<li><a href="/interview/docs/offer/EntryNodeOfLoop/">链表中环的入口</a></li>
<li><a href="/interview/docs/offer/IsSymmetrical/">对称二叉树</a></li>
<li><a href="/interview/docs/offer/SerializeTree/">序列化二叉树</a></li>
<li><a href="/interview/docs/offer/StreamMid/">数据流中的中位数</a></li>
<li><a href="/interview/docs/offer/NOfNumberSerialize/">数字序列中的某一位的数字</a></li>
<li><a href="/interview/docs/offer/TranslateNumToStr/">把数字翻译成字符串</a></li>
<li><a href="/interview/docs/offer/MaxGift/">礼物的最大价值</a></li>
<li><a href="/interview/docs/offer/LongestNoRepeatSubString/">最长不含重复字符的子字符串</a></li>
<li><a href="/interview/docs/offer/CountOfSortedArray/">在排序数组中查找数字</a></li>
<li><a href="/interview/docs/offer/BSTKthNode/">二叉搜索树的第K大节点</a></li>
<li><a href="/interview/docs/offer/MaxInWindows/">滑动窗口的最大值</a></li>
<li><a href="/interview/docs/offer/MaxProfit/">股票的最大利润</a></li>
</ul>
</li>
<li><a href="/interview/docs/leetcode/">LeetCode</a>
<ul>
<li><a href="/interview/docs/leetcode/lengthOfLongestSubstring/">* 无重复字符的最长子串</a></li>
<li><a href="/interview/docs/leetcode/longestCommonPrefix/">最长公共前缀</a></li>
<li><a href="/interview/docs/leetcode/checkInclusion/">字符串的排列</a></li>
<li><a href="/interview/docs/leetcode/StringMultiply/">字符串相乘</a></li>
<li><a href="/interview/docs/leetcode/reverseWords/">翻转字符串里的单词</a></li>
<li><a href="/interview/docs/leetcode/simplifyPath/">* 简化路径</a></li>
<li><a href="/interview/docs/leetcode/restoreIpAddresses/">* 复原IP地址</a></li>
<li><a href="/interview/docs/leetcode/threeSum/">* 三数之和</a></li>
<li><a href="/interview/docs/leetcode/maxAreaOfIsland/">* 岛屿的最大面积</a></li>
<li><a href="/interview/docs/leetcode/searchRote/">* 搜索旋转排序数组</a></li>
<li><a href="/interview/docs/leetcode/findLengthOfLCIS/">最长连续递增序列</a></li>
<li><a href="/interview/docs/leetcode/findKthLargest/">数组中的第K个最大元素</a></li>
<li><a href="/interview/docs/leetcode/longestConsecutive/">最长连续序列</a></li>
<li><a href="/interview/docs/leetcode/findCircleNum/">* 朋友圈</a></li>
<li><a href="/interview/docs/leetcode/mergeRagen/">合并区间</a></li>
<li><a href="/interview/docs/leetcode/trap/">* 接雨水</a></li>
<li><a href="/interview/docs/leetcode/mergeTwoLists/">合并两个有序链表</a></li>
<li><a href="/interview/docs/leetcode/reverseList/">* 反转链表</a></li>
<li><a href="/interview/docs/leetcode/addTwoNumbers/">* 两数相加</a></li>
<li><a href="/interview/docs/leetcode/sortList/">* 排序链表</a></li>
<li><a href="/interview/docs/leetcode/detectCycle/">环形链表 II</a></li>
<li><a href="/interview/docs/leetcode/getIntersectionNode/">相交链表</a></li>
<li><a href="/interview/docs/leetcode/mergeKLists/">* 合并K个排序链表</a></li>
<li><a href="/interview/docs/leetcode/lowestCommonAncestor/">二叉树的最近公共祖先</a></li>
<li><a href="/interview/docs/leetcode/zigzagLevelOrder/">二叉树的锯齿形层次遍历</a></li>
<li><a href="/interview/docs/leetcode/maxProfit/">* 买卖股票的最佳时机</a></li>
<li><a href="/interview/docs/leetcode/maxProfit2/">* 买卖股票的最佳时机 II</a></li>
<li><a href="/interview/docs/leetcode/maxSubArray/">最大子序和</a></li>
<li><a href="/interview/docs/leetcode/MinStack/">* 最小栈</a></li>
<li><a href="/interview/docs/leetcode/LRUCache/">* LRU缓存机制</a></li>
<li><a href="/interview/docs/leetcode/AllOne/">全 O(1) 的数据结构</a></li>
<li><a href="/interview/docs/leetcode/mySqrt/">* x 的平方根</a></li>
<li><a href="/interview/docs/leetcode/validUtf8/">* UTF-8 编码验证</a></li>
<li><a href="/interview/docs/leetcode/salary/">* 第二高的薪水</a></li>
</ul>
</li>
</ul>





</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/interview/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>
  <strong>I/O</strong>
</header>

      
<article class="markdown"><h1 id="io">I/O</h1>
<h2 id="基本概念">基本概念</h2>
<h3 id="文件描述符fd">文件描述符fd</h3>
<p>文件描述符（<code>File descriptor</code>）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于 <code>UNIX、Linux</code> 这样的操作系统。</p>
<h3 id="缓存-io">缓存 I/O</h3>
<p>缓存 <code>I/O</code> 又被称作标准 <code>I/O</code>，大多数文件系统的默认 <code>I/O</code> 操作都是缓存 <code>I/O</code>。在 <code>Linux</code> 的<code>缓存 I/O</code> 机制中，操作系统会将 <code>I/O</code> 的数据缓存在文件系统的页缓存（ <code>page cache</code> ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<p>缓存 I/O 的缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 <code>CPU</code> 以及内存开销是非常大的。</p>
<h2 id="io模式">IO模式</h2>
<p>刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备</li>
<li>将数据从内核拷贝到进程中</li>
</ol>
<p>正式因为这两个阶段，Linux系统产生了下面五种网络模式的方案。</p>
<ul>
<li><code>阻塞 I/O</code>（blocking IO）</li>
<li><code>非阻塞 I/O</code>（nonblocking IO）</li>
<li><code>I/O 多路复用</code>（ IO multiplexing）</li>
<li><code>信号驱动 I/O</code>（ signal driven IO）</li>
<li><code>异步 I/O</code>（asynchronous IO）</li>
</ul>
<blockquote>
<p>由于signal driven IO在实际中并不常用，所以这里只提及剩下的四种 IO Model。</p>
</blockquote>
<h3 id="阻塞io">阻塞IO</h3>
<p>在 <code>Linux</code> 中，默认情况下所有的 <code>socket</code> 都是 <code>blocking</code> ，一个典型的读操作流程大概是这样：</p>
<p><img src="images/359a774ea7d5d1e6ac08845023993796.png" alt=""></p>
<p>当用户进程调用了 <code>recvfrom</code> 这个系统调用， <code>kernel</code> 就开始了 IO 的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的 <code>UDP</code> 包。这个时候 <code>kernel</code> 就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当 <code>kernel</code> 一直等到数据准备好了，它就会将数据从 <code>kernel</code> 中拷贝到用户内存，然后 <code>kernel</code> 返回结果，用户进程才解除 <code>block</code> 的状态，重新运行起来。</p>
<blockquote>
<p>blocking IO的特点就是在IO执行的两个阶段都被block了</p>
</blockquote>
<h3 id="非阻塞-io">非阻塞 I/O</h3>
<p><code>Linux</code> 下，可以通过设置 <code>socket</code> 使其变为 <code>non-blocking</code> 。当对一个 <code>non-blocking socket</code> 执行读操作时，流程是这个样子：</p>
<p><img src="images/076dcab40e2b43efa5d1aa97d96a85e2.png" alt=""></p>
<p>当用户进程发出 <code>read</code> 操作时，如果 <code>kernel</code> 中的数据还没有准备好，那么它并不会 <code>block</code> 用户进程，而是立刻返回一个 <code>error</code> 。从用户进程角度讲 ，它发起一个 <code>read</code> 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 <code>error</code> 时，它就知道数据还没有准备好，于是它可以再次发送 <code>read</code> 操作。一旦 <code>kernel</code> 中的数据准备好了，并且又再次收到了用户进程的 <code>system call</code> ，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<blockquote>
<p>nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有</p>
</blockquote>
<h3 id="io多路复用">IO多路复用</h3>
<p>IO多路复用就是我们说的 <code>select，poll，epoll</code> ，有些地方也称这种IO方式为 <code>event driven IO</code> 。<code>select/epoll</code> 的好处就在于单个 <code>process</code> 就可以同时处理多个网络连接的 IO 。它的基本原理就是 <code>select，poll，epoll</code> 这个 <code>function</code> 会不断的轮询所负责的所有 <code>socket</code> ，当某个 <code>socket</code> 有数据到达了，就通知用户进程。</p>
<p><img src="images/c6d2db53d71a8c76c2c9a546c5811773.png" alt=""></p>
<p><strong>当用户进程调用了 select，那么整个进程会被 block</strong>，而同时， <code>kernel</code> 会监视所有 <code>select</code> 负责的 <code>socket</code> ，当任何一个 <code>socket</code> 中的数据准备好了， <code>select</code> 就会返回。这个时候用户进程再调用 <code>read</code> 操作，将数据从 <code>kernel</code> 拷贝到用户进程。</p>
<blockquote>
<p>I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，<code>select()</code> 函数就可以返回。</p>
</blockquote>
<p>这个图和 <code>blocking IO</code> 的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个 <code>system call</code> (<code>select</code> 和 <code>recvfrom</code>)，而 <code>blocking IO</code> 只调用了一个 <code>system call</code> (<code>recvfrom</code>)。但是，用 <code>select</code> 的优势在于它可以同时处理多个 <code>connection</code> 。</p>
<p>所以，<strong>如果处理的连接数不是很高的话，使用 <code>select/epoll</code> 的 <code>web server</code> 不一定比使用 <code>multi-threading + blocking IO</code> 的 <code>web server</code> 性能更好，可能延迟还更大</strong>。<code>select/epoll</code> 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
<p>在IO多路复用实际使用中，对于每一个socket，一般都设置成为 <code>non-blocking</code> ，但是，如上图所示，整个用户的 <code>process</code> 其实是一直被block的。只不过 <code>process</code> 是被 <code>select</code> 这个函数 <code>block</code> ，而不是被 <code>socket IO</code> 给 <code>block</code> 。</p>
<h4 id="基本概念-1">基本概念</h4>
<p>在 I/O 编程过程中,当需要同时处理多个客户端接入请求时，可以利用多线程或者 <code>I/O 多路复用</code> 技术进行处理。<strong><code>I/O多路复用</code> 技术通过把多个I/O的阻塞复用到同一个selct的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求</strong>。<strong>与传统的 <code>多线程/多进程</code> 模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源</strong>，I/O多路复用的主要应用场景如下。</p>
<ul>
<li>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字</li>
<li>服务器需要同时处理多种网络协议的套接字</li>
</ul>
<p>目前支持I/O多路复用的系统调用有 <code>select、pselect、poll、epoll</code>，在Linux网络编程; 过程中，很长一段时间都使用 <code>select</code> 做轮询和网络事件通知，然而 <code>select</code> 的一些固有缺陷导致了它的应用受到了很大的限制。最终 <code>Linux</code> 不得不在新的内核版本中寻找 <code>select</code> 的替代方案，最终选择了 <code>epoll</code>。 <code>epoll</code> 与 <code>select</code> 的原理比较类似，为了克服 <code>select</code> 的缺点， <code>epoll</code> 作了很多重大改进，现总结如下。</p>
<h5 id="支持一个进程打开的-socket-描述符fd不受限制仅受限于操作系统的最大文件句柄数">支持一个进程打开的 socket 描述符（FD）不受限制（仅受限于操作系统的最大文件句柄数）。</h5>
<p><strong><code>select</code> 最大的缺陷就是单个进程所打开的 FD 是有一定限制的</strong>，它由 <code>FD_SETSIZE</code> 设置，默认值是 <code>1024</code> 。对于那些需要支持上万个 TCP 连接的大型服务器来说显然太少了。可以选择修改这个宏然后重新编译内核，不过这会带来网络效率的下降。我们也可以通过选择多进程的方案（传统的 Apache 方案）解决这个问题，不过虽然在 Linux上创建进程的代价比较小，但仍旧是不可忽视的，另外，进程间的数据交换非常麻烦，对于 Java 由于没有共享内存，需要通过 <code>Socket</code> 通信或者其他方式进行数据同步，这带来了额外的性能损耗，增加了程序复杂度，所以也不是一种完美的解决方案。值得庆幸的是， <code>epoll</code> 并没有这个限制，它所支持的 <code>FD</code> 上限是操作系统的 <strong>最大文件句柄数</strong>，这个数字远远大于 <code>1024</code> 。例如，在 <code>1 GB</code> 内存的机器上大约是 10万个句柄左右，具体的值可以通过<code>cat /proc/sys/fs/file- max</code> 察看，<strong>通常情况下这个值跟系统的内存关系比较大</strong>。</p>
<h5 id="io效率不会随着fd数目的增加而线性下降">I/O效率不会随着FD数目的增加而线性下降。</h5>
<p>传统的 <code>select/poll</code> 另-个致命弱点就是当你拥有一个很大的 <code>socket</code> 集合，由于网络延时或者链路空闲，任一时刻只有少部分的 <code>socket</code> 是“活跃”的，但是 <strong><code>select/poll</code> 每次调用都会线性扫描全部的集合，导致效率呈现线性下降</strong>。 <code>epoll</code> 不存在这个问题，它只会对“活跃”的 <code>socket</code> 进行操作，这是因为在内核实现中 <code>epoll</code> 是根据每个 <code>fd</code> 上面的 <code>callback</code> 函数实现的，那么，只有“活跃”的 <code>socket</code> 才会主动的去调用 <code>callback</code> 函数，其他 <code>idle</code> 状态 <code>socket</code> 则不会。<strong>在这点上， <code>epoll</code> 实现了一个伪 AIO</strong>。针对 <code>epoll</code> 和 <code>select</code> 性能对比的 <code>benchmark</code> 测试表明：<strong>如果所有的 <code>socket</code> 都处于活跃态，例如一个高速 <code>LAN</code> 环境， <code>epoll</code> 并不比 <code>select/poll</code> 效率高太多；相反，如果过多使用 <code>epoll_ ctl</code> , 效率相比还有稍微的下降。但是一旦使用 <code>idleconnections</code> 模拟 <code>WAN</code> 环境，<code>epoll</code> 的效率就远在 <code>select/poll</code> 之上了</strong>。</p>
<h5 id="使用-mmap-加速内核与用户空间的消息传递">使用 mmap 加速内核与用户空间的消息传递</h5>
<p>无论是 <code>select</code>，<code>poll</code> 还是 <code>epoll</code> 都需要内核把 FD 消息通知给用户空间，如何避免不必要的内存复制（Zero Copy）就显得非常重要， <code>epoll</code> 是通过内核和用户空间 <code>mmap</code> 共享同一块内存来实现。</p>
<h5 id="epoll-的-api-更加简单">Epoll 的 API 更加简单</h5>
<p>包括创建一个 <code>epoll</code> 描述符、添加监听事件、阻塞等待所监听的事件发生，关闭 <code>epoll</code> 描述符等。</p>
<p>值得说明的是，用来克服 <code>select/poll</code> 缺点的方法不只有 <code>epoll</code> , <code>epoll</code> 只是一种 <code>Linux</code> 的 实现方案。在 <code>freeBSD</code> 下有 <code>kqueue</code></p>
<h3 id="epoll-边缘触发水平触发">Epoll 边缘触发&amp;水平触发</h3>
<p>epoll 对文件描述符的操作有两种模式：LT（<code>level trigger</code>）和ET（<code>edge trigger</code>）。LT模式是 <strong>默认模式</strong> ，LT模式与ET模式的区别如下：</p>
<ul>
<li><strong>LT模式</strong>：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。</li>
<li><strong>ET模式</strong>：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。</li>
</ul>
<blockquote>
<p>ET模式 在很大程度上减少了 epoll 事件被重复触发的次数，因此 <strong>效率要比LT模式高</strong>。epoll 工作在ET模式的时候，<strong>必须使用非阻塞套接口</strong>，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p>
</blockquote>
<h2 id="异步-io">异步 I/O</h2>
<p><img src="images/3b385bdf805241ee6cd0d4634bd7510a.png" alt=""></p>
<p>用户进程发起 <code>read</code> 操作之后，立刻就可以开始去做其它的事。而另一方面，从 <code>kernel</code> 的角度，当它受到一个 <code>asynchronous read</code> 之后，首先它会立刻返回，所以不会对用户进程产生任何 <code>block</code> 。然后，<code>kernel</code> 会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，<code>kernel</code> 会给用户进程发送一个 <code>signal</code> ，告诉它 <code>read</code> 操作完成了。</p>
<h2 id="blocking-vs-non-blocking">blocking vs non-blocking</h2>
<p>调用 <code>blocking IO</code> 会一直 <code>block</code> 住对应的进程直到操作完成，而 <code>non-blocking IO</code> 在 <code>kernel</code> 还准备数据的情况下会立刻返回。</p>
<h2 id="synchronous-io-vs-asynchronous-io">synchronous IO vs asynchronous IO</h2>
<p>在说明<code>synchronous IO</code>和<code>asynchronous IO</code>的区别之前，需要先给出两者的定义。 <code>POSIX</code> 的定义是这样子的：</p>
<ul>
<li>A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;</li>
<li>An asynchronous I/O operation does not cause the requesting process to be blocked;</li>
</ul>
<p>两者的区别就在于 <code>synchronous IO</code> 做 <code>IO operation</code> 的时候会将 <code>process</code> 阻塞。按照这个定义，之前所述的 <code>blocking IO，non-blocking IO，IO multiplexing</code> 都属于 <code>synchronous IO</code>。</p>
<p>有人会说，<code>non-blocking IO</code> 并没有被 <code>block</code> 啊。这里有个非常 <strong>狡猾</strong> 的地方，定义中所指的 <code>IO operation</code> 是指真实的 IO 操作，就是例子中的 <code>recvfrom</code> 这个 <code>system call</code> 。<code>non-blocking IO</code> 在执行 <code>recvfrom</code> 这个 <code>system call</code> 的时候，如果 <code>kernel</code> 的数据没有准备好，这时候不会 <code>block</code> 进程。但是，当 <code>kernel</code> 中数据准备好的时候，<code>recvfrom</code> 会将数据从 <code>kernel</code> 拷贝到用户内存中，这个时候进程是被 <code>block</code> 了，在这段时间内，进程是被 <code>block</code> 的。</p>
<p>而 <code>asynchronous IO</code> 则不一样，当进程发起 <code>IO</code> 操作之后，就直接返回再也不理睬了，直到 <code>kernel</code> 发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被 <code>block</code> 。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://segmentfault.com/a/1190000003063859">Linux IO模式及 select、poll、epoll详解</a></li>
</ul>
</article>

      <div class="book-footer justify-between">
  

  
  
  <div>
    
    <a class="flex align-center" href="https://github.com/hadyang/interview/commit/3ad3981966ea48cf0201c427c96db9656e45e265" title='Last modified by haoyang.shi | 2020-01-19' target="_blank">
      <img src="/interview/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>2020-01-19</span>
    </a>
  </div>
  
  

  
  <div>
    <a class="flex align-center" href="https://github.com/hadyang/interview/edit/master/content/docs/basic/os/io/index.md" target="_blank">
      <img src="/interview/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>
  

</div>

      
    </div>

    
  

  <aside class="book-toc levels-3 fixed">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#基本概念">基本概念</a>
      <ul>
        <li><a href="#文件描述符fd">文件描述符fd</a></li>
        <li><a href="#缓存-io">缓存 I/O</a></li>
      </ul>
    </li>
    <li><a href="#io模式">IO模式</a>
      <ul>
        <li><a href="#阻塞io">阻塞IO</a></li>
        <li><a href="#非阻塞-io">非阻塞 I/O</a></li>
        <li><a href="#io多路复用">IO多路复用</a></li>
        <li><a href="#epoll-边缘触发水平触发">Epoll 边缘触发&水平触发</a></li>
      </ul>
    </li>
    <li><a href="#异步-io">异步 I/O</a></li>
    <li><a href="#blocking-vs-non-blocking">blocking vs non-blocking</a></li>
    <li><a href="#synchronous-io-vs-asynchronous-io">synchronous IO vs asynchronous IO</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
  </aside>



  </main>

  
</body>

</html>
