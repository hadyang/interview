<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Interview</title>
    <link>https://hadyang.github.io/interview/docs/java/gc/</link>
    <description>Recent content on Interview</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 21 Aug 2019 11:00:41 +0800</lastBuildDate>
    
	<atom:link href="https://hadyang.github.io/interview/docs/java/gc/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>JVM 垃圾回收</title>
      <link>https://hadyang.github.io/interview/docs/java/gc/jvm-gc/</link>
      <pubDate>Wed, 21 Aug 2019 11:00:41 +0800</pubDate>
      
      <guid>https://hadyang.github.io/interview/docs/java/gc/jvm-gc/</guid>
      <description>JVM垃圾回收  本片文章均指 HotSpot 的GC
 Java堆中存放着大量的Java对象实例，在垃圾收集器回收内存前，第一件事情就是确定哪些对象是“活着的”，哪些是可以回收的。
引用计数算法 引用计数算法是判断对象是否存活的基本算法：给每个对象添加一个引用计数器，没当一个地方引用它的时候，计数器值加1；当引用失效后，计数器值减1。但是这种方法有一个致命的缺陷，当两个对象相互引用时会导致这两个都无法被回收。
根搜索算法 在主流的商用语言中（Java、C#&amp;hellip;）都是使用根搜索算法来判断对象是否存活。对于程序来说，根对象总是可以访问的。从这些根对象开始，任何可以被触及的对象都被认为是&amp;quot;活着的&amp;quot;的对象。无法触及的对象被认为是垃圾，需要被回收。
Java虚拟机的根对象集合根据实现不同而不同，但是总会包含以下几个方面：
 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中的类静态属性引用的变量。 方法区中的常量引用的变量。 本地方法JNI的引用对象。  区分活动对象和垃圾的两个基本方法是引用计数和根搜索。 引用计数是通过为堆中每个对象保存一个计数来区分活动对象和垃圾。根搜索算法实际上是追踪从根结点开始的引用图。
引用对象 引用对象封装了指向其他对象的连接：被指向的对象称为引用目标。Reference有三个直接子类SoftReference、WeakReference、PhantomReference分别代表：软引用、弱引用、虚引用。强引用在Java中是普遍存在的，类似Object o = new Object();这类引用就是强引用，强引用和以上引用的区别在于：强引用禁止引用目标被垃圾收集器收集，而其他引用不禁止。
 当使用软引用、弱引用、虚引用时，并且对可触及性状态的改变有兴趣，可以把引用对象和引用队列关联起来。
 对象有六种可触及状态变化：
  强可触及：对象可以从根节点不通过任何引用对象搜索到。垃圾收集器不会回收这个对象的内存空间。
  软可触及：对象可以从根节点通过一个或多个(未被清除的)软引用对象触及，垃圾收集器在要发生内存溢出前将这些对象列入回收范围中进行回收，如果该软引用对象和引用队列相关联，它会把该软引用对象加入队列。
 SoftReference 可以用来创建内存中缓存，JVM 的实现需要在抛出 OutOfMemoryError 之前清除软引用（SoftReference），但在其他的情况下可以选择清理的时间或者是否清除它们。
   弱可触及：对象可以从根节点开始通过一个或多个(未被清除的)弱引用对象触及，垃圾收集器在一次 GC 的时候会回收所有的弱引用对象（WeakReference），如果该弱引用对象和引用队列相关联，它会把该弱引用对象加入队列。
  可复活的：对象既不是强可触及、软可触及、也不是弱可触及，但仍然可能通过执行某些终结方法复活到这几个状态之一。
 Java类可以通过重写 finalize 方法复活准备回收的对象，但 finalize 方法只是在对象第一次回收时会调用。
   虚可触及：垃圾收集器不会清除一个虚引用（PhantomReference），所有的虚引用都必须由程序明确的清除。 同时也不能通过虚引用来取得一个对象的实例。
  不可触及：不可触及对象已经准备好回收了。
   若一个对象的引用类型有多个，那到底如何判断它的可达性呢？其实规则如下：
 单条引用链的可达性以最弱的一个引用类型来决定； 多条引用链的可达性以最强的一个引用类型来决定；   垃圾回收算法 标记&amp;ndash;清除算法 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，标记的方法使用根搜索算法。主要有两个缺点：</description>
    </item>
    
    <item>
      <title>对象的生命周期</title>
      <link>https://hadyang.github.io/interview/docs/java/gc/jvm-object-lifecycle/</link>
      <pubDate>Wed, 21 Aug 2019 11:00:41 +0800</pubDate>
      
      <guid>https://hadyang.github.io/interview/docs/java/gc/jvm-object-lifecycle/</guid>
      <description>对象的生命周期 一旦一个类被装载、连接和初始化，它就随时可以被使用。程序可以访问它的静态字段，调用它的静态方法，或者创建它的实例。作为Java程序员有必要了解Java对象的生命周期。
类实例化 在Java程序中，类可以被明确或隐含地实例化。明确的实例化类有四种途径：
 明确调用new。 调用Class或者java.lang.reflect.Constructor对象的newInstance方法。 调用任何现有对象的clone。 通过java.io.ObjectInputStream.getObject()反序列化。  隐含的实例化：
 可能是保存命令行参数的String对象。 对于Java虚拟机装载的每个类，都会暗中实例化一个Class对象来代表这个类型 当Java虚拟机装载了在常量池中包含CONSTANT_String_info入口的类的时候，它会创建新的String对象来表示这些常量字符串。 执行包含字符串连接操作符的表达式会产生新的对象。  Java编译器为它编译的每个类至少生成一个实例初始化方法。在Java class文件中，这个方法被称为&amp;lt;init&amp;gt;。针对源代码中每个类的构造方法，Java编译器都会产生一个&amp;lt;init&amp;gt;()方法。如果类没有明确的声明任何构造方法，编译器会默认产生一个无参数的构造方法，它仅仅调用父类的无参构造方法。
一个&amp;lt;init&amp;gt;()中可能包含三种代码：调用另一个&amp;lt;init&amp;gt;()、实现对任何实例变量的初始化、构造方法体的代码。
如果构造方法明确的调用了同一个类中的另一个构造方法(this())，那么它对应的&amp;lt;init&amp;gt;()由两部分组成：
 一个同类的&amp;lt;init&amp;gt;()的调用。 实现了对应构造方法的方法体的字节码。   在它对应的&amp;lt;init&amp;gt;()方法中不会有父类的&amp;lt;init&amp;gt;()，但不代表不会调用父类的&amp;lt;init&amp;gt;()，因为this()中也会调用父类&amp;lt;init&amp;gt;()
 如果构造方法不是通过一个this()调用开始的，而且这个对象不是Object，&amp;lt;init&amp;gt;()则有三部分组成：
 一个父类的&amp;lt;init&amp;gt;()调用。如果这个类是Object,则没有这个部分 任意实例变量初始化方法的字节码。 实现了对应构造方法的方法体的字节码。  如果构造方法明确的调用父类的构造方法super()开始，它的&amp;lt;init&amp;gt;()会调用对应父类的&amp;lt;init&amp;gt;()。比如，如果一个构造方法明确的调用super(int,String)开始，对应的&amp;lt;init&amp;gt;()会从调用父类的&amp;lt;init&amp;gt;(int,String)方法开始。如果构造方法没有明确地从this()或super()开始，对应的&amp;lt;init&amp;gt;()默认会调用父类的无参&amp;lt;init&amp;gt;()。
垃圾收集和对象的终结 程序可以明确或隐含的为对象分配内存，但不能明确的释放内存。一个对象不再为程序引用，虚拟机必须回收那部分内存。
卸载类 在很多方面，Java虚拟机中类的生命周期和对象的生命周期很相似。当程序不再使用某个类的时候，可以选择卸载它们。
 类的垃圾收集和卸载值所以在Java虚拟机中很重要，是因为Java程序可以在运行时通过用户自定义的类装载器装载类型来动态的扩展程序。所有被装载的类型都在方法区占据内存空间。
 Java虚拟机通过判断类是否在被引用来进行垃圾收集。判断动态装载的类的Class实例在正常的垃圾收集过程中是否可触及有两种方式：
 如果程序保持非Class实例的明确引用。 如果在堆中还存在一个可触及的对象，在方法区中它的类型数据指向一个Class实例。  </description>
    </item>
    
  </channel>
</rss>