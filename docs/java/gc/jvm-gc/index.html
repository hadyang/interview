<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="JVM 垃圾回收"><meta property="og:title" content="JVM 垃圾回收" />
<meta property="og:description" content="JVM垃圾回收  本片文章均指 HotSpot 的GC
 Java堆中存放着大量的Java对象实例，在垃圾收集器回收内存前，第一件事情就是确定哪些对象是“活着的”，哪些是可以回收的。
引用计数算法 引用计数算法是判断对象是否存活的基本算法：给每个对象添加一个引用计数器，没当一个地方引用它的时候，计数器值加1；当引用失效后，计数器值减1。但是这种方法有一个致命的缺陷，当两个对象相互引用时会导致这两个都无法被回收。
根搜索算法 在主流的商用语言中（Java、C#&hellip;）都是使用根搜索算法来判断对象是否存活。对于程序来说，根对象总是可以访问的。从这些根对象开始，任何可以被触及的对象都被认为是&quot;活着的&quot;的对象。无法触及的对象被认为是垃圾，需要被回收。
Java虚拟机的根对象集合根据实现不同而不同，但是总会包含以下几个方面：
 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中的类静态属性引用的变量。 方法区中的常量引用的变量。 本地方法JNI的引用对象。  区分活动对象和垃圾的两个基本方法是引用计数和根搜索。 引用计数是通过为堆中每个对象保存一个计数来区分活动对象和垃圾。根搜索算法实际上是追踪从根结点开始的引用图。
引用对象 引用对象封装了指向其他对象的连接：被指向的对象称为引用目标。Reference有三个直接子类SoftReference、WeakReference、PhantomReference分别代表：软引用、弱引用、虚引用。强引用在Java中是普遍存在的，类似Object o = new Object();这类引用就是强引用，强引用和以上引用的区别在于：强引用禁止引用目标被垃圾收集器收集，而其他引用不禁止。
 当使用软引用、弱引用、虚引用时，并且对可触及性状态的改变有兴趣，可以把引用对象和引用队列关联起来。
 对象有六种可触及状态变化：
  强可触及：对象可以从根节点不通过任何引用对象搜索到。垃圾收集器不会回收这个对象的内存空间。
  软可触及：对象可以从根节点通过一个或多个(未被清除的)软引用对象触及，垃圾收集器在要发生内存溢出前将这些对象列入回收范围中进行回收，如果该软引用对象和引用队列相关联，它会把该软引用对象加入队列。
 SoftReference 可以用来创建内存中缓存，JVM 的实现需要在抛出 OutOfMemoryError 之前清除软引用（SoftReference），但在其他的情况下可以选择清理的时间或者是否清除它们。
   弱可触及：对象可以从根节点开始通过一个或多个(未被清除的)弱引用对象触及，垃圾收集器在一次 GC 的时候会回收所有的弱引用对象（WeakReference），如果该弱引用对象和引用队列相关联，它会把该弱引用对象加入队列。
  可复活的：对象既不是强可触及、软可触及、也不是弱可触及，但仍然可能通过执行某些终结方法复活到这几个状态之一。
 Java类可以通过重写 finalize 方法复活准备回收的对象，但 finalize 方法只是在对象第一次回收时会调用。
   虚可触及：垃圾收集器不会清除一个虚引用（PhantomReference），所有的虚引用都必须由程序明确的清除。 同时也不能通过虚引用来取得一个对象的实例。
  不可触及：不可触及对象已经准备好回收了。
   若一个对象的引用类型有多个，那到底如何判断它的可达性呢？其实规则如下：
 单条引用链的可达性以最弱的一个引用类型来决定； 多条引用链的可达性以最强的一个引用类型来决定；   垃圾回收算法 标记&ndash;清除算法 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，标记的方法使用根搜索算法。主要有两个缺点：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://hadyang.github.io/interview/docs/java/gc/jvm-gc/" />
<meta property="article:published_time" content="2019-08-21T11:00:41+08:00" />
<meta property="article:modified_time" content="2020-01-19T16:59:43+08:00" />
<title>JVM 垃圾回收 | Interview</title>
<link rel="icon" href="/interview/favicon.png" type="image/x-icon">


<link rel="stylesheet" href="/interview/book.min.68d45956421753cdf6bcfc865ede445c56afc5bcaaebfe02961f44fe77d8f45a.css" integrity="sha256-aNRZVkIXU832vPyGXt5EXFavxbyq6/4Clh9E/nfY9Fo=">


<script defer src="/interview/en.search.min.5bf2d60b3ca94e31f496269ddbd413773f2c27366f3fd210ebd7da7e377b105e.js" integrity="sha256-W/LWCzypTjH0liad29QTdz8sJzZvP9IQ69fafjd7EF4="></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-157595781-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->

  
</head>

<body>
  <input type="checkbox" class="hidden" id="menu-control" />
  <main class="flex container">

    <aside class="book-menu fixed">
      <nav>
<h2 class="book-brand">
  <a href="https://hadyang.github.io/interview/"><span>Interview</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" />
  <div class="book-search-spinner spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>





    <ul>
<li><a href="/interview/docs/basic/">计算机基础</a>
<ul>
<li><a href="/interview/docs/basic/algo/">算法</a>
<ul>
<li><a href="/interview/docs/basic/algo/tree/">树</a></li>
<li><a href="/interview/docs/basic/algo/hash/">Hash</a></li>
<li><a href="/interview/docs/basic/algo/mst/">最小生成树算法</a></li>
<li><a href="/interview/docs/basic/algo/path/">最短路径算法</a></li>
<li><a href="/interview/docs/basic/algo/kmp/">KMP算法</a></li>
<li><a href="/interview/docs/basic/algo/search/">查找算法</a></li>
<li><a href="/interview/docs/basic/algo/sort/">排序算法</a></li>
<li><a href="/interview/docs/basic/algo/skip_list/">跳跃表</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/os/">操作系统</a>
<ul>
<li><a href="/interview/docs/basic/os/arch/">计算机体系结构</a></li>
<li><a href="/interview/docs/basic/os/concurrency/">并发</a></li>
<li><a href="/interview/docs/basic/os/memory/">内存管理</a></li>
<li><a href="/interview/docs/basic/os/disk/">磁盘与文件</a></li>
<li><a href="/interview/docs/basic/os/linux/">Linux系统</a></li>
<li><a href="/interview/docs/basic/os/interrupt/">中断</a></li>
<li><a href="/interview/docs/basic/os/device/">设备管理</a></li>
<li><a href="/interview/docs/basic/os/io/">I/O</a></li>
<li><a href="/interview/docs/basic/os/questions/">面试题</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/net/">计算机网络</a>
<ul>
<li><a href="/interview/docs/basic/net/protocol/">底层网络协议</a></li>
<li><a href="/interview/docs/basic/net/tcp/">TCP</a></li>
<li><a href="/interview/docs/basic/net/ip/">IP</a></li>
<li><a href="/interview/docs/basic/net/http/">HTTP</a></li>
<li><a href="/interview/docs/basic/net/https/">HTTPS</a></li>
<li><a href="/interview/docs/basic/net/websocket/">Websocket</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/database/">数据库</a>
<ul>
<li><a href="/interview/docs/basic/database/transaction/">事务</a></li>
<li><a href="/interview/docs/basic/database/index/">索引</a></li>
<li><a href="/interview/docs/basic/database/sql/">SQL</a></li>
<li><a href="/interview/docs/basic/database/join/">连接</a></li>
<li><a href="/interview/docs/basic/database/mysql/">MySQL</a></li>
<li><a href="/interview/docs/basic/database/concurrent/">并发控制</a></li>
<li><a href="/interview/docs/basic/database/innodb/">Innodb</a></li>
<li><a href="/interview/docs/basic/database/redis/">Redis</a></li>
</ul>
</li>
<li><a href="/interview/docs/basic/cryptology/">密码学</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/">Java</a>
<ul>
<li><a href="/interview/docs/java/oop/">OOP</a></li>
<li><a href="/interview/docs/java/serilaser/">序列化</a></li>
<li><a href="/interview/docs/java/operator/">运算符</a></li>
<li><a href="/interview/docs/java/exception/">异常</a></li>
<li><a href="/interview/docs/java/generics/">泛型</a></li>
<li><a href="/interview/docs/java/object/">Object</a></li>
<li><a href="/interview/docs/java/string-builder/">StringBuilder</a></li>
<li><a href="/interview/docs/java/proxy/">代理</a></li>
<li><a href="/interview/docs/java/annotation/">注解</a></li>
<li><a href="/interview/docs/java/questions/">面试题</a></li>
<li><a href="/interview/docs/java/nio/">NIO</a></li>
<li><a href="/interview/docs/java/">集合</a>
<ul>
<li><a href="/interview/docs/java/collection/HashMap/">HashMap</a></li>
<li><a href="/interview/docs/java/collection/Concurrenthashmap/">Concurrenthashmap</a></li>
<li><a href="/interview/docs/java/collection/BlockQueue/">BlockQueue</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/concurrent/">并发</a>
<ul>
<li><a href="/interview/docs/java/concurrent/thread/">线程</a></li>
<li><a href="/interview/docs/java/concurrent/volatile/">Volatile</a></li>
<li><a href="/interview/docs/java/concurrent/atomic/">AtomicInteger</a></li>
<li><a href="/interview/docs/java/concurrent/synchronized/">Synchronized</a></li>
<li><a href="/interview/docs/java/concurrent/AQS/">AQS</a></li>
<li><a href="/interview/docs/java/concurrent/count-down-latch/">CountDownLatch</a></li>
<li><a href="/interview/docs/java/concurrent/threadlocal/">Threadlocal</a></li>
<li><a href="/interview/docs/java/concurrent/interrupt/">线程中断</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/jvm/">Java 虚拟机</a>
<ul>
<li><a href="/interview/docs/java/jvm/jvm-class-load-init/">类加载</a></li>
<li><a href="/interview/docs/java/jvm/jvm-class-loader/">类加载器</a></li>
<li><a href="/interview/docs/java/jvm/dispatcher/">Java分派机制</a></li>
<li><a href="/interview/docs/java/jvm/jvm-architecture/">虚拟机架构</a></li>
<li><a href="/interview/docs/java/jvm/memory-model/">内存模型</a></li>
<li><a href="/interview/docs/java/jvm/string-constant-pool/">String 常量池</a></li>
</ul>
</li>
<li><a href="/interview/docs/java/gc/">GC</a>
<ul>
<li><a href="/interview/docs/java/gc/jvm-gc/"class=active>Java 虚拟机垃圾收集</a></li>
<li><a href="/interview/docs/java/gc/jvm-object-lifecycle/">Java 虚拟机对象生命周期</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/interview/docs/fromwork/">框架</a>
<ul>
<li><a href="/interview/docs/fromwork/netty/">Netty</a></li>
<li><a href="/interview/docs/fromwork/mybatis/">Mybatis</a>
<ul>
<li><a href="/interview/docs/fromwork/mybatis/question/">面试题</a></li>
<li><a href="/interview/docs/fromwork/mybatis/cache/">缓存</a></li>
<li><a href="/interview/docs/fromwork/mybatis/proxy/">代理</a></li>
</ul>
</li>
<li><a href="/interview/docs/fromwork/spring/">Spring</a>
<ul>
<li><a href="/interview/docs/fromwork/spring/ioc/">IOC</a></li>
<li><a href="/interview/docs/fromwork/spring/design-partten/">设计模式</a></li>
<li><a href="/interview/docs/fromwork/spring/aop/">AOP</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/interview/docs/architecture/">系统架构</a>
<ul>
<li><a href="/interview/docs/architecture/base/">基本概念</a></li>
<li><a href="/interview/docs/architecture/concurrent/">高并发</a>
<ul>
<li><a href="/interview/docs/architecture/concurrent/flow-control/">流量控制</a></li>
</ul>
</li>
<li><a href="/interview/docs/architecture/design/">系统设计</a>
<ul>
<li><a href="/interview/docs/architecture/design/tinyURL/">短链接系统</a></li>
</ul>
</li>
<li><a href="/interview/docs/architecture/distributed/">分布式</a>
<ul>
<li><a href="/interview/docs/architecture/distributed/consensus/">分布式一致性与共识算法</a></li>
<li><a href="/interview/docs/architecture/distributed/session/">分布式Session</a></li>
<li><a href="/interview/docs/architecture/distributed/cache/">分布式缓存</a></li>
<li><a href="/interview/docs/architecture/distributed/lock/">分布式锁</a></li>
<li><a href="/interview/docs/architecture/distributed/transaction/">分布式事务</a></li>
<li><a href="/interview/docs/architecture/distributed/mq/">消息队列</a></li>
<li><a href="/interview/docs/architecture/distributed/zk/">Zookeeper</a></li>
<li><a href="/interview/docs/architecture/distributed/kafka/">Kafka</a></li>
<li><a href="/interview/docs/architecture/distributed/rpc/">远程调用</a></li>
<li><a href="/interview/docs/architecture/distributed/dubbo/">Dubbo</a></li>
</ul>
</li>
<li><a href="/interview/docs/architecture/bigdata/">大数据</a>
<ul>
<li><a href="/interview/docs/architecture/bigdata/algo/">基础算法</a></li>
<li><a href="/interview/docs/architecture/bigdata/hdfs/">HDFS</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="/interview/docs/offer/">剑指offer</a>
<ul>
<li><a href="/interview/docs/offer/search-a-2d-matrix/">搜索二维矩阵</a></li>
<li><a href="/interview/docs/offer/replay-space/">替换空格</a></li>
<li><a href="/interview/docs/offer/print-link-from-tail/">从尾到头打印链表</a></li>
<li><a href="/interview/docs/offer/reConstructBinaryTree/">重建二叉树</a></li>
<li><a href="/interview/docs/offer/two-stack-fifo/">用两个栈实现一个队列</a></li>
<li><a href="/interview/docs/offer/find-minimum-in-rotated-sorted-array/">旋转数组的最小数字</a></li>
<li><a href="/interview/docs/offer/fibonacci/">斐波纳切数列</a></li>
<li><a href="/interview/docs/offer/number-of-one/">二进制中1的个数</a></li>
<li><a href="/interview/docs/offer/power/">数值的整数次方</a></li>
<li><a href="/interview/docs/offer/printn/">打印最大的 n 位数</a></li>
<li><a href="/interview/docs/offer/O1DeleteNode/">在O(1)的时间复杂度下删除节点</a></li>
<li><a href="/interview/docs/offer/reOrderArray/">调整数组顺序使奇数位于偶数前面</a></li>
<li><a href="/interview/docs/offer/FindKthToTail/">链表中倒数第k个结点</a></li>
<li><a href="/interview/docs/offer/revert-link/">反转链表</a></li>
<li><a href="/interview/docs/offer/merge-sort-link/">合并两个排序的链表</a></li>
<li><a href="/interview/docs/offer/HasSubtree/">树的子结构</a></li>
<li><a href="/interview/docs/offer/mirror-tree/">二叉树的镜像</a></li>
<li><a href="/interview/docs/offer/PrintMatrix/">顺时针打印矩阵</a></li>
<li><a href="/interview/docs/offer/MinStack/">包含min函数的栈</a></li>
<li><a href="/interview/docs/offer/IsPopOrder/">栈的压入、弹出序列</a></li>
<li><a href="/interview/docs/offer/PrintFromTopToBottom/">从上往下打印二叉树</a></li>
<li><a href="/interview/docs/offer/VerifySquenceOfBST/">二叉搜索树的后序遍历序列</a></li>
<li><a href="/interview/docs/offer/FindPath/">二叉树中和为某一值的路径</a></li>
<li><a href="/interview/docs/offer/CloneLink/">复杂链表的复制</a></li>
<li><a href="/interview/docs/offer/BST-Link-Convert/">二叉搜索树与双向链表</a></li>
<li><a href="/interview/docs/offer/Permutation/">字符串的排列</a></li>
<li><a href="/interview/docs/offer/MoreThanHalfNum/">数组中出现次数超过一半的数字</a></li>
<li><a href="/interview/docs/offer/GetLeastNumbers/">最小的K个数</a></li>
<li><a href="/interview/docs/offer/FindGreatestSumOfSubArray/">连续子数组的最大和</a></li>
<li><a href="/interview/docs/offer/NumberOfOneBetweenOneAndN/">从1到n整数中1出现的次数</a></li>
<li><a href="/interview/docs/offer/PrintMinNumber/">把数组排成最小的数</a></li>
<li><a href="/interview/docs/offer/GetUglyNumber/">丑数</a></li>
<li><a href="/interview/docs/offer/FirstNotRepeatingChar/">第一个只出现一次的字符</a></li>
<li><a href="/interview/docs/offer/InversePairs/">数组中的逆序对</a></li>
<li><a href="/interview/docs/offer/FindFirstCommonNode/">两个链表的第一个公共结点</a></li>
<li><a href="/interview/docs/offer/GetNumberOfK/">数字在排序数组中出现的次数</a></li>
<li><a href="/interview/docs/offer/TreeDepth/">二叉树的深度</a></li>
<li><a href="/interview/docs/offer/FindNumsAppearOnce/">数组中只出现一次的数字</a></li>
<li><a href="/interview/docs/offer/FindNumbersWithSum/">和为S的两个数字</a></li>
<li><a href="/interview/docs/offer/FindContinuousSequence/">和为S的连续正数序列</a></li>
<li><a href="/interview/docs/offer/ReverseSentence/">翻转单词顺序列</a></li>
<li><a href="/interview/docs/offer/LeftRotateString/">左旋转字符串</a></li>
<li><a href="/interview/docs/offer/SumOfNDice/">n个骰子的点数</a></li>
<li><a href="/interview/docs/offer/isContinuous/">扑克牌顺子</a></li>
<li><a href="/interview/docs/offer/LastRemaining/">圆圈中最后剩下的数</a></li>
<li><a href="/interview/docs/offer/sum/">求1+2+3+&hellip;+n</a></li>
<li><a href="/interview/docs/offer/Add/">不用加减乘除做加法</a></li>
<li><a href="/interview/docs/offer/Singleton/">单例</a></li>
<li><a href="/interview/docs/offer/Duplicate/">数组中重复的数字</a></li>
<li><a href="/interview/docs/offer/GetNext/">二叉树的下一个结点</a></li>
<li><a href="/interview/docs/offer/hasPath/">矩阵中的路径</a></li>
<li><a href="/interview/docs/offer/MovingCount/">机器人的运动范围</a></li>
<li><a href="/interview/docs/offer/CutRope/">剪绳子</a></li>
<li><a href="/interview/docs/offer/PatternMatch/">正则表达式匹配</a></li>
<li><a href="/interview/docs/offer/IsNumeric/">表示数值的字符串</a></li>
<li><a href="/interview/docs/offer/EntryNodeOfLoop/">链表中环的入口</a></li>
<li><a href="/interview/docs/offer/IsSymmetrical/">对称二叉树</a></li>
<li><a href="/interview/docs/offer/SerializeTree/">序列化二叉树</a></li>
<li><a href="/interview/docs/offer/StreamMid/">数据流中的中位数</a></li>
<li><a href="/interview/docs/offer/NOfNumberSerialize/">数字序列中的某一位的数字</a></li>
<li><a href="/interview/docs/offer/TranslateNumToStr/">把数字翻译成字符串</a></li>
<li><a href="/interview/docs/offer/MaxGift/">礼物的最大价值</a></li>
<li><a href="/interview/docs/offer/LongestNoRepeatSubString/">最长不含重复字符的子字符串</a></li>
<li><a href="/interview/docs/offer/CountOfSortedArray/">在排序数组中查找数字</a></li>
<li><a href="/interview/docs/offer/BSTKthNode/">二叉搜索树的第K大节点</a></li>
<li><a href="/interview/docs/offer/MaxInWindows/">滑动窗口的最大值</a></li>
<li><a href="/interview/docs/offer/MaxProfit/">股票的最大利润</a></li>
</ul>
</li>
<li><a href="/interview/docs/leetcode/">LeetCode</a>
<ul>
<li><a href="/interview/docs/leetcode/lengthOfLongestSubstring/">* 无重复字符的最长子串</a></li>
<li><a href="/interview/docs/leetcode/longestCommonPrefix/">最长公共前缀</a></li>
<li><a href="/interview/docs/leetcode/checkInclusion/">字符串的排列</a></li>
<li><a href="/interview/docs/leetcode/StringMultiply/">字符串相乘</a></li>
<li><a href="/interview/docs/leetcode/reverseWords/">翻转字符串里的单词</a></li>
<li><a href="/interview/docs/leetcode/simplifyPath/">* 简化路径</a></li>
<li><a href="/interview/docs/leetcode/restoreIpAddresses/">* 复原IP地址</a></li>
<li><a href="/interview/docs/leetcode/threeSum/">* 三数之和</a></li>
<li><a href="/interview/docs/leetcode/maxAreaOfIsland/">* 岛屿的最大面积</a></li>
<li><a href="/interview/docs/leetcode/searchRote/">* 搜索旋转排序数组</a></li>
<li><a href="/interview/docs/leetcode/findLengthOfLCIS/">最长连续递增序列</a></li>
<li><a href="/interview/docs/leetcode/findKthLargest/">数组中的第K个最大元素</a></li>
<li><a href="/interview/docs/leetcode/longestConsecutive/">最长连续序列</a></li>
<li><a href="/interview/docs/leetcode/findCircleNum/">* 朋友圈</a></li>
<li><a href="/interview/docs/leetcode/mergeRagen/">合并区间</a></li>
<li><a href="/interview/docs/leetcode/trap/">* 接雨水</a></li>
<li><a href="/interview/docs/leetcode/mergeTwoLists/">合并两个有序链表</a></li>
<li><a href="/interview/docs/leetcode/reverseList/">* 反转链表</a></li>
<li><a href="/interview/docs/leetcode/addTwoNumbers/">* 两数相加</a></li>
<li><a href="/interview/docs/leetcode/sortList/">* 排序链表</a></li>
<li><a href="/interview/docs/leetcode/detectCycle/">环形链表 II</a></li>
<li><a href="/interview/docs/leetcode/getIntersectionNode/">相交链表</a></li>
<li><a href="/interview/docs/leetcode/mergeKLists/">* 合并K个排序链表</a></li>
<li><a href="/interview/docs/leetcode/lowestCommonAncestor/">二叉树的最近公共祖先</a></li>
<li><a href="/interview/docs/leetcode/zigzagLevelOrder/">二叉树的锯齿形层次遍历</a></li>
<li><a href="/interview/docs/leetcode/maxProfit/">* 买卖股票的最佳时机</a></li>
<li><a href="/interview/docs/leetcode/maxProfit2/">* 买卖股票的最佳时机 II</a></li>
<li><a href="/interview/docs/leetcode/maxSubArray/">最大子序和</a></li>
<li><a href="/interview/docs/leetcode/MinStack/">* 最小栈</a></li>
<li><a href="/interview/docs/leetcode/LRUCache/">* LRU缓存机制</a></li>
<li><a href="/interview/docs/leetcode/AllOne/">全 O(1) 的数据结构</a></li>
<li><a href="/interview/docs/leetcode/mySqrt/">* x 的平方根</a></li>
<li><a href="/interview/docs/leetcode/validUtf8/">* UTF-8 编码验证</a></li>
<li><a href="/interview/docs/leetcode/salary/">* 第二高的薪水</a></li>
</ul>
</li>
</ul>





</nav>


<script>
(function() {
  var menu = document.querySelector("aside.book-menu nav");
  addEventListener("beforeunload", function(event) {
    localStorage.setItem("menu.scrollTop", menu.scrollTop);
  });
  menu.scrollTop = localStorage.getItem("menu.scrollTop");
})();
</script>

    </aside>

    <div class="book-page">
      <header class="flex align-center justify-between book-header">
  <label for="menu-control">
    <img src="/interview/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>
  <strong>JVM 垃圾回收</strong>
</header>

      
<article class="markdown"><h1 id="jvm垃圾回收">JVM垃圾回收</h1>
<blockquote>
<p>本片文章均指 HotSpot 的GC</p>
</blockquote>
<p>Java堆中存放着大量的Java对象实例，在垃圾收集器回收内存前，第一件事情就是确定哪些对象是“活着的”，哪些是可以回收的。</p>
<h2 id="引用计数算法">引用计数算法</h2>
<p>引用计数算法是判断对象是否存活的基本算法：给每个对象添加一个引用计数器，没当一个地方引用它的时候，计数器值加1；当引用失效后，计数器值减1。但是这种方法有一个致命的缺陷，<strong>当两个对象相互引用时会导致这两个都无法被回收</strong>。</p>
<h2 id="根搜索算法">根搜索算法</h2>
<p>在主流的商用语言中（Java、C#&hellip;）都是使用根搜索算法来判断对象是否存活。对于程序来说，根对象总是可以访问的。<em>从这些根对象开始，任何可以被触及的对象都被认为是&quot;活着的&quot;的对象。无法触及的对象被认为是垃圾，需要被回收</em>。</p>
<p>Java虚拟机的根对象集合根据实现不同而不同，但是总会包含以下几个方面：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中的类静态属性引用的变量。</li>
<li>方法区中的常量引用的变量。</li>
<li>本地方法JNI的引用对象。</li>
</ul>
<p><strong>区分活动对象和垃圾的两个基本方法是引用计数和根搜索。</strong> 引用计数是通过为堆中每个对象保存一个计数来区分活动对象和垃圾。根搜索算法实际上是追踪从根结点开始的引用图。</p>
<h2 id="引用对象">引用对象</h2>
<p>引用对象封装了指向其他对象的连接：被指向的对象称为引用目标。<code>Reference</code>有三个直接子类<code>SoftReference</code>、<code>WeakReference</code>、<code>PhantomReference</code>分别代表：软引用、弱引用、虚引用。强引用在Java中是普遍存在的，类似<code>Object o = new Object();</code>这类引用就是强引用，强引用和以上引用的区别在于：<strong>强引用禁止引用目标被垃圾收集器收集，而其他引用不禁止。</strong></p>
<blockquote>
<p>当使用软引用、弱引用、虚引用时，并且对可触及性状态的改变有兴趣，可以把引用对象和引用队列关联起来。</p>
</blockquote>
<p>对象有六种可触及状态变化：</p>
<ul>
<li>
<p><code>强可触及</code>：对象可以从根节点不通过任何引用对象搜索到。垃圾收集器不会回收这个对象的内存空间。</p>
</li>
<li>
<p><code>软可触及</code>：对象可以从根节点通过一个或多个(未被清除的)软引用对象触及，垃圾收集器在要发生内存溢出前将这些对象列入回收范围中进行回收，如果该软引用对象和引用队列相关联，它会把该软引用对象加入队列。</p>
<blockquote>
<p>SoftReference 可以用来创建内存中缓存，<strong>JVM 的实现需要在抛出 OutOfMemoryError 之前清除软引用（SoftReference）</strong>，但在其他的情况下可以选择清理的时间或者是否清除它们。</p>
</blockquote>
</li>
<li>
<p><code>弱可触及</code>：对象可以从根节点开始通过一个或多个(未被清除的)弱引用对象触及，<strong>垃圾收集器在一次 GC 的时候会回收所有的弱引用对象（WeakReference）</strong>，如果该弱引用对象和引用队列相关联，它会把该弱引用对象加入队列。</p>
</li>
<li>
<p><code>可复活的</code>：对象既不是强可触及、软可触及、也不是弱可触及，但仍然可能通过执行某些终结方法复活到这几个状态之一。</p>
<blockquote>
<p>Java类可以通过重写 finalize 方法复活准备回收的对象，但 finalize 方法只是在对象第一次回收时会调用。</p>
</blockquote>
</li>
<li>
<p><code>虚可触及</code>：<strong>垃圾收集器不会清除一个虚引用（PhantomReference），所有的虚引用都必须由程序明确的清除。</strong> 同时也不能通过虚引用来取得一个对象的实例。</p>
</li>
<li>
<p><code>不可触及</code>：不可触及对象已经准备好回收了。</p>
</li>
</ul>
<blockquote>
<p>若一个对象的引用类型有多个，那到底如何判断它的可达性呢？其实规则如下：</p>
<ol>
<li>单条引用链的可达性以最弱的一个引用类型来决定；</li>
<li>多条引用链的可达性以最强的一个引用类型来决定；</li>
</ol>
</blockquote>
<h2 id="垃圾回收算法">垃圾回收算法</h2>
<h3 id="标记--清除算法">标记&ndash;清除算法</h3>
<p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，标记的方法使用根搜索算法。主要有两个缺点：</p>
<ul>
<li>
<p>效率问题，标记和清除的效率都不高。</p>
</li>
<li>
<p>空间问题，标记清除后会产生大量不连续的内存碎片。</p>
</li>
</ul>
<h3 id="复制回收算法">复制回收算法</h3>
<p>将可用内存分为大小相等的两份，在同一时刻只使用其中的一份。当这一份内存使用完了，就将还存活的对象复制到另一份上，然后将这一份上的内存清空。复制算法能有效避免内存碎片，但是算法需要将内存一分为二，导致内存使用率大大降低。</p>
<h3 id="标记--整理算法">标记&ndash;整理算法</h3>
<p>复制算法在对象存活率较高的情况下会复制很多的对象，效率会很低。标记&ndash;整理算法就解决了这样的问题，标记过程和标记&ndash;清除算法一样，但后续是将所有存活的对象都移动到内存的一端，然后清理掉端外界的对象。</p>
<h2 id="分代回收hotspot">分代回收(HotSpot)</h2>
<p>在JVM中不同的对象拥有不同的生命周期，因此对于不同生命周期的对象也可以采用不同的垃圾回收方法，以提高效率，这就是分代回收算法的核心思想。</p>
<p>在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费的时间相对会长。同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。</p>
<p>JVM中的共划分为三个代：<code>新生代（Young Generation）</code>、<code>老年代（Old Generation）</code>和<code>永久代（Permanent Generation）</code>。其中永久代主要存放的是Java类的类信息，与垃圾收集要收集的Java对象关系不大。</p>
<p><img src="images/jvm-gc-1.jpg" alt=""></p>
<ul>
<li>
<p><code>新生代</code>：所有新生成的对象首先都是放在新生代的，新生代采用复制回收算法。新生代的目标就是尽可能快速的收集掉那些生命周期短的对象。新生代分三个区。一个Eden区，两个Survivor区(一般而言)。<strong>大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当一个对象经过多次的 GC 后还没有被回收，那么它将被移动到“年老区(Tenured)”</strong>。需要注意，Survivor 的两个区是对称的，没先后关系，所以同一个区中可能同时存在从 Eden 复制过来 对象，和从前一个 Survivor 复制过来的对象，而复制到年老区的只有从第一个 Survivor 去过来的对象。而且，Survivor 区总有一个是空的。</p>
<blockquote>
<p>在HotSpot虚拟机内部默认Eden和Survivor的大小比例是8:1， 也就是每次新生代中可用内存为整个新生代的90%，这大大提高了复制回收算法的效率。</p>
</blockquote>
</li>
<li>
<p><code>老年代</code>：在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到老年代中，老年代采用标记整理回收算法。因此，可以认为老年代中存放的都是一些生命周期较长的对象。</p>
</li>
<li>
<p><code>永久代</code>：HotSpot 的方法区实现，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据</p>
</li>
</ul>
<h2 id="hotspot-各版本永久代变化">HotSpot 各版本永久代变化</h2>
<ul>
<li>在Java 6中，方法区中包含的数据，除了JIT编译生成的代码存放在<code>native memory</code>的<code>CodeCache</code>区域，其他都存放在永久代；</li>
<li>在Java 7中，<code>Symbol</code> 的存储从 <code>PermGen</code> 移动到了 <code>native memory</code> ，并且把静态变量从<code>instanceKlass</code>末尾（位于<code>PermGen</code>内）移动到了<code>java.lang.Class</code>对象的末尾（位于普通<code>Java heap</code>内）；</li>
<li>在Java 8中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间（<code>Metaspace</code>）,<code>‑XX:MaxPermSize</code> 参数失去了意义，取而代之的是<code>-XX:MaxMetaspaceSize</code>。</li>
</ul>
<h3 id="移除永久代httpswwwsczyh30compostsjavajvm-metaspace"><a href="https://www.sczyh30.com/posts/Java/jvm-metaspace/">移除永久代</a></h3>
<p><code>Java 8</code> 彻底将永久代 (<code>PermGen</code>) 移除出了 <code>HotSpot JVM</code>，将其原有的数据迁移至 <code>Java Heap</code> 或 <code>Metaspace</code>。</p>
<p>在 <code>HotSpot JVM</code> 中，永久代中用于存放类和方法的元数据以及常量池，比如<code>Class</code>和<code>Method</code>。每当一个类初次被加载的时候，它的元数据都会放到永久代中。</p>
<p><strong>永久代是有大小限制的</strong>，因此如果加载的类太多，很有可能导致永久代内存溢出，即万恶的 <code>java.lang.OutOfMemoryError: PermGen</code> ，为此我们不得不对虚拟机做调优。</p>
<p>那么，<code>Java 8</code> 中 <code>PermGen</code> 为什么被移出 <code>HotSpot JVM</code> 了？</p>
<ul>
<li>由于 · 内存经常会溢出，引发恼人的 <code>java.lang.OutOfMemoryError: PermGen</code>，因此 <code>JVM</code> 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的 <code>OOM</code></li>
<li>移除 <code>PermGen</code> 可以促进<code> HotSpot JVM</code> 与 <code>JRockit VM</code> 的融合，因为 <code>JRockit</code> 没有永久代。</li>
</ul>
<p><code>根据上面的各种原因，PermGen</code> 最终被移除，<strong>方法区移至 Metaspace，字符串常量移至 Java Heap</strong>。</p>
<h3 id="元空间">元空间</h3>
<p>首先，Metaspace（元空间）是哪一块区域？官方的解释是：</p>
<blockquote>
<p>In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.</p>
</blockquote>
<p>也就是说，JDK 8 开始把类的元数据放到本地堆内存(native heap)中，这一块区域就叫 Metaspace，中文名叫元空间。</p>
<h2 id="垃圾回收触发条件">垃圾回收触发条件</h2>
<p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。对于一个拥有终结方法的对象，在垃圾收集器释放对象前必须执行终结方法。但是当垃圾收集器第二次收集这个对象时便不会再次调用终结方法。</p>
<h3 id="scavenge-gc">Scavenge GC</h3>
<p>一般情况下，当新对象生成，并且在 <code>Eden</code> 申请空间失败时，就会触发 <code>Scavenge GC</code>，对 <code>Eden</code> 区域进行 <code>GC</code> ，清除非存活对象，并且把尚且存活的对象移动到 <code>Survivor</code> 区，然后整理 <code>Survivor</code> 的两个区。这种方式的 GC是对新生代的 Eden 区进行，不会影响到老年代。因为大部分对象都是从 Eden 区开始的，同时 Eden 区不会分配的很大，所以 Eden 区的 GC 会频繁进行。</p>
<h3 id="full-gc">Full GC</h3>
<p>对整个堆进行整理，包括 <code>Young</code> 、 <code>Tenured</code> 和 <code>Perm</code> 。Full GC因为需要对整个对进行回收，所以比 <code>Scavenge GC</code> 要慢，因此应该尽可能减少 <code>Full GC</code> 的次数。在对 JVM 调优的过程中，很大一部分工作就是对于 FullGC 的调节。有如下原因可能导致Full GC：</p>
<ul>
<li>老年代（Tenured）被写满</li>
<li>永久代（Perm）被写满</li>
<li>System.gc()被显示调用</li>
</ul>
<h3 id="堆外内存-gc">堆外内存 GC</h3>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html">Native Memory Tracking</a></p>
<p><code>DirectBuffer</code> 的引用是直接分配在堆得 <code>Old</code> 区的，因此其回收时机是在 <code>FullGC</code> 时。因此，需要避免频繁的分配 <code>DirectBuffer</code> ，这样很容易导致 <code>Native Memory</code> 溢出。</p>
<p><code>DirectByteBuffer</code> 申请的直接内存，不再GC范围之内，无法自动回收。JDK提供了一种机制，可以为堆内存对象注册一个钩子函数(其实就是实现 <code>Runnable</code> 接口的子类)，当堆内存对象被GC回收的时候，会回调run方法，我们可以在这个方法中执行释放 <code>DirectByteBuffer</code> 引用的直接内存，即在run方法中调用 <code>Unsafe</code> 的 <code>freeMemory</code> 方法。注册是通过<code>sun.misc.Cleaner</code>类来实现的。</p>
<h2 id="垃圾收集器">垃圾收集器</h2>
<p>垃圾收集器是内存回收的具体实现，下图展示了7种用于不同分代的收集器，两个收集器之间有连线表示可以搭配使用。下面的这些收集器没有“最好的”这一说，每种收集器都有最适合的使用场景。</p>
<p><img src="images/hotspot-jvm-1.6-garbage-collector.jpg" alt=""></p>
<h3 id="serial收集器">Serial收集器</h3>
<p><strong>Serial收集器是最基本的收集器，这是一个单线程收集器，它“单线程”的意义不仅仅是说明它只用一个线程去完成垃圾收集工作，更重要的是在它进行垃圾收集工作时，必须暂停其他工作线程，直到它收集完成</strong>。Sun将这件事称之为”Stop the world“。</p>
<blockquote>
<p>没有一个收集器能完全不停顿，只是停顿的时间长短。</p>
</blockquote>
<p>虽然Serial收集器的缺点很明显，但是它仍然是JVM在Client模式下的默认新生代收集器。它有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比较），Serial收集器由于没有线程交互的开销，专心只做垃圾收集自然也获得最高的效率。在用户桌面场景下，分配给JVM的内存不会太多，停顿时间完全可以在几十到一百多毫秒之间，只要收集不频繁，这是完全可以接受的。</p>
<h3 id="parnew收集器">ParNew收集器</h3>
<p>ParNew是Serial的多线程版本，在回收算法、对象分配原则上都是一致的。ParNew收集器是许多运行在Server模式下的默认新生代垃圾收集器，其主要在于除了Serial收集器，目前只有ParNew收集器能够与CMS收集器配合工作。</p>
<h3 id="parallel-scavenge收集器18默认新生代">Parallel Scavenge收集器（1.8默认新生代）</h3>
<p>Parallel Scavenge收集器是一个新生代垃圾收集器，其使用的算法是<code>复制算法</code>，也是并行的多线程收集器。</p>
<p>Parallel Scavenge 收集器更关注可控制的吞吐量，吞吐量等于运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)。直观上，只要最大的垃圾收集停顿时间越小，吞吐量是越高的，但是GC停顿时间的缩短是以牺牲吞吐量和新生代空间作为代价的。比如原来10秒收集一次，每次停顿100毫秒，现在变成5秒收集一次，每次停顿70毫秒。停顿时间下降的同时，吞吐量也下降了。</p>
<p>停顿时间越短就越适合需要与用户交互的程序；而高吞吐量则可以最高效的利用CPU的时间，尽快的完成计算任务，主要适用于后台运算。</p>
<h3 id="serial-old收集器">Serial Old收集器</h3>
<p>Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，采用“标记-整理算法”进行回收。其运行过程与Serial收集器一样。</p>
<h3 id="parallel-old收集器18默认老年代">Parallel Old收集器（1.8默认老年代）</h3>
<p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和<code>标记-整理</code>算法进行垃圾回收。其通常与Parallel Scavenge收集器配合使用，“吞吐量优先”收集器是这个组合的特点，在注重吞吐量和CPU资源敏感的场合，都可以使用这个组合。</p>
<h3 id="cms-收集器">CMS 收集器</h3>
<p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短停顿时间为目标的收集器，CMS收集器采用<code>标记--清除</code>算法，运行在老年代。主要包含以下几个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发清除</li>
</ul>
<p>其中初始标记和重新标记仍然需要“Stop the world”。初始标记仅仅标记GC Root能直接关联的对象，并发标记就是进行GC Root Tracing过程，而重新标记则是为了修正并发标记期间，因用户程序继续运行而导致标记变动的那部分对象的标记记录。</p>
<p>由于整个过程中最耗时的并发标记和并发清除，收集线程和用户线程一起工作，所以总体上来说，CMS收集器回收过程是与用户线程并发执行的。虽然CMS优点是并发收集、低停顿，很大程度上已经是一个不错的垃圾收集器，但是还是有三个显著的缺点：</p>
<ul>
<li>
<p><strong>CMS收集器对CPU资源很敏感</strong>。在并发阶段，虽然它不会导致用户线程停顿，但是会因为占用一部分线程（CPU资源）而导致应用程序变慢。</p>
</li>
<li>
<p><strong>CMS收集器不能处理浮动垃圾</strong>。所谓的“浮动垃圾”，就是在并发标记阶段，由于用户程序在运行，那么自然就会有新的垃圾产生，这部分垃圾被标记过后，CMS无法在当次集中处理它们，只好在下一次GC的时候处理，这部分未处理的垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段程序还需要运行，即还需要预留足够的内存空间供用户使用，因此CMS收集器不能像其他收集器那样等到老年代几乎填满才进行收集，需要预留一部分空间提供并发收集时程序运作使用。要是CMS预留的内存空间不能满足程序的要求，这是JVM就会启动预备方案：临时启动Serial Old收集器来收集老年代，这样停顿的时间就会很长。</p>
</li>
<li>
<p><strong>由于CMS使用标记&ndash;清除算法，所以在收集之后会产生大量内存碎片</strong>。当内存碎片过多时，将会给分配大对象带来困难，这是就会进行Full GC。</p>
</li>
</ul>
<h3 id="g1收集器">G1收集器</h3>
<p>G1收集器与CMS相比有很大的改进：</p>
<ul>
<li>G1收集器采用标记&ndash;整理算法实现。</li>
<li>可以非常精确地控制停顿。</li>
</ul>
<p><strong>G1收集器可以实现在基本不牺牲吞吐量的情况下完成低停顿的内存回收，这是由于它极力的避免全区域的回收，G1收集器将Java堆（包括新生代和老年代）划分为多个区域（Region），并在后台维护一个优先列表，每次根据允许的时间，优先回收垃圾最多的区域</strong> 。</p>
</article>

      <div class="book-footer justify-between">
  

  
  
  <div>
    
    <a class="flex align-center" href="https://github.com/hadyang/interview/commit/3ad3981966ea48cf0201c427c96db9656e45e265" title='Last modified by haoyang.shi | 2020-01-19' target="_blank">
      <img src="/interview/svg/calendar.svg" class="book-icon" alt="Calendar" />
      <span>2020-01-19</span>
    </a>
  </div>
  
  

  
  <div>
    <a class="flex align-center" href="https://github.com/hadyang/interview/edit/master/content/docs/java/gc/jvm-gc/index.md" target="_blank">
      <img src="/interview/svg/edit.svg" class="book-icon" alt="Edit" />
      <span>Edit this page</span>
    </a>
  </div>
  

</div>

      
    </div>

    
  

  <aside class="book-toc levels-3 fixed">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#引用计数算法">引用计数算法</a></li>
    <li><a href="#根搜索算法">根搜索算法</a></li>
    <li><a href="#引用对象">引用对象</a></li>
    <li><a href="#垃圾回收算法">垃圾回收算法</a>
      <ul>
        <li><a href="#标记--清除算法">标记&ndash;清除算法</a></li>
        <li><a href="#复制回收算法">复制回收算法</a></li>
        <li><a href="#标记--整理算法">标记&ndash;整理算法</a></li>
      </ul>
    </li>
    <li><a href="#分代回收hotspot">分代回收(HotSpot)</a></li>
    <li><a href="#hotspot-各版本永久代变化">HotSpot 各版本永久代变化</a>
      <ul>
        <li><a href="#移除永久代httpswwwsczyh30compostsjavajvm-metaspace">移除永久代</a></li>
        <li><a href="#元空间">元空间</a></li>
      </ul>
    </li>
    <li><a href="#垃圾回收触发条件">垃圾回收触发条件</a>
      <ul>
        <li><a href="#scavenge-gc">Scavenge GC</a></li>
        <li><a href="#full-gc">Full GC</a></li>
        <li><a href="#堆外内存-gc">堆外内存 GC</a></li>
      </ul>
    </li>
    <li><a href="#垃圾收集器">垃圾收集器</a>
      <ul>
        <li><a href="#serial收集器">Serial收集器</a></li>
        <li><a href="#parnew收集器">ParNew收集器</a></li>
        <li><a href="#parallel-scavenge收集器18默认新生代">Parallel Scavenge收集器（1.8默认新生代）</a></li>
        <li><a href="#serial-old收集器">Serial Old收集器</a></li>
        <li><a href="#parallel-old收集器18默认老年代">Parallel Old收集器（1.8默认老年代）</a></li>
        <li><a href="#cms-收集器">CMS 收集器</a></li>
        <li><a href="#g1收集器">G1收集器</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </aside>



  </main>

  
</body>

</html>
