# 内存管理

## 内存管理方式

### 页式存储

  - 逻辑空间等分为页；并从0开始编号
  - 内存空间等分为块，与页面大小相同；从0开始编号
  - 分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。

![](page.png)

### 段式存储

  - 逻辑空间分为若干个段，每个段定义了一组有完整逻辑意义的信息（如主程序`Main()`）。
  - 内存空间为每个段分配一个连续的分区。

![](segment.png)

分页和分段的主要区别：

  - 分页：信息的物理单位。大小一样，由系统决定。地址空间是一维的。
  - 分段：信息的逻辑单位。大小不一样，由程序员决定。地址空间是二维的。

### 段页式存储

用户程序先分段，每个段内部再分页（内部原理同基本的分页、分段相同）

![](segment-page.png)

## 内存分配

- `虚拟地址`：用户编程时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称 + 段内相对地址构成，这样的程序地址称为虚拟地址
- `逻辑地址`：虚拟地址中，段内相对地址部分称为逻辑地址
- `物理地址`：实际物理内存中所看到的存储地址称为物理地址

- `逻辑地址空间`：在实际应用中，将虚拟地址和逻辑地址经常不加区分，通称为逻辑地址。逻辑地址的集合称为逻辑地址空间
- `线性地址空间`：CPU地址总线可以访问的所有地址集合称为线性地址空间
- `物理地址空间`：实际存在的可访问的物理内存地址集合称为物理地址空间

- `MMU(Memery Management Unit内存管理单元)`：实现将用户程序的虚拟地址（逻辑地址） -> 物理地址映射的CPU中的硬件电路
- `基地址`：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算
- `偏移量`：在以段或页为单位进行地址映射时，相对于基地址的地址值

**虚拟地址先经过分段机制映射到线性地址，然后线性地址通过分页机制映射到物理地址**。

## 虚拟内存

- 请求调页，也称按需调页，即对不在内存中的“页”，当进程执行时要用时才调入，否则有可能到程序结束时也不会调入

### 页面置换算法

  - FIFO算法：先入先出，即淘汰最早调入的页面。

  - OPT(MIN)算法：选未来最远将使用的页淘汰，是一种最优的方案，可以证明缺页数最小。可惜，MIN需要知道将来发生的事，只能在理论中存在，实际不可应用。

  - LRU(Least-Recently-Used)算法：用过去的历史预测将来，选最近最长时间没有使用的页淘汰(也称最近最少使用)。性能最接近OPT。

  - `Clock`：**给每个页帧关联一个使用位**，当该页第一次装入内存或者被重新访问到时，将使用位置为1。每次需要替换时，查找使用位被置为0的第一个帧进行替换。在扫描过程中，如果碰到使用位为1的帧，将使用位置为0，在继续扫描。如果所谓帧的使用位都为0，则替换第一个帧。

`内存抖动现象`：页面的频繁更换，导致整个系统效率急剧下降，这个现象称为内存抖动（或颠簸）。抖动一般是内存分配算法不好，内存太小引或者程序的算法不佳引起的。
